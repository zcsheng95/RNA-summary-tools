#' getLegend
#' Helper function for getting legend
#' @param gplot ggplot type of plot
#' @return legend element of plot
#' @export
#'

getLegend<-function(gplot){
  tmp <- ggplot_gtable(ggplot_build(gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}



#' starPCA
#' Function for calculating PCA
#' @importFrom DESeq2 counts vst
#' @importFrom matrixStats rowVars
#' @importFrom stats prcomp
#' @param object an RNAqc object
#' @param ntop use top genes to calculate PCA
#' @export
#' @return dataframe ready for pca plot
#'
starPCA <- function(object,ntop = 1000){
  if(!all(colnames(object) == colnames(counts(object)))){stop("Sample names not in same order!")}
  if(sum(is.na(normAssay(object))) != 0){ncounts <- assay(vst(object = object))
  }else ncounts <- normAssay(object) 
  rv <- matrixStats::rowVars(ncounts)
  idx <- order(rv, decreasing = TRUE)[seq_len(min(ntop,length(rv)))]
  pca <- prcomp(t(ncounts[idx, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  dat_pca <- as.data.frame(colData(object)) %>%
    rownames_to_column(var = "label") %>%
    mutate(pc1 = pca$x[, 1],
           pc2 = pca$x[, 2],
           pc3 = pca$x[, 3])
  return(list(dat_pca,percentVar))
}


#' pcPlot
#' Create PCA plot 
#' @param df input dataframe
#' @param vars grouping variables
#' @param labels sample id
#' @param pc principal components to compare
#' @param ... size and alpha for geom_point
#' @return ggplot type pca plot
#' 
#' 

pcPlot <- function(df, vars, labels, pc,...){
  
  pc_1 = paste0("pc",pc)[1]
  pc_2 = paste0("pc",pc)[2]
  g <- ggplot(df, aes_string(x = pc_1, y = pc_2,
                            color=vars,
                            label = "label")) +
    geom_point(...) +
    labs(color="") +
    # geom_text()+
    geom_vline(xintercept=0, linetype = "dashed") +
    geom_hline(yintercept=0, linetype = "dashed") +
    theme_classic() +
    theme(legend.position = "bottom")
   if(labels == TRUE){
     g <- g + geom_text_repel(segment.size = 0.2, segment.color = "grey50", direction =
                                "both",force = 5)
       
   }
  return(g)
}



#' createPCplot
#' This function takes the meta data and star counts 
#' use DESeq2 for estimating size factors before considering any experiment designs.
#' It requires the column names of the input count data matrix and the row names of the metadata have the same order
#' @import ggrepel
#' @importFrom gridExtra grid.arrange arrangeGrob
#' @param object an RNAqc object
#' @param var grouping variables
#' @param labels show the labels or not
#' @param ... size and alpha for geom_point
#' @param pc select pcs to plot p1:p1 vs p2, p2:p1 vs p3, p3:p3 vs p2
#' @param allocation the user-defined allocation for 3 pc plots, 'flat' in 1 row, 'align' in 2 rows
#' @return PCA plot for pc1 vs pc2, pc1 vs pc3, pc3 vs pc2
#' @export


createPCplot <- function(object, var, labels = FALSE, pc = NULL, allocation = 'flat',...){
  out <- starPCA(object)
  pcadf <- out[[1]]
  percentVar <- out[[2]]
  xl <- paste0("PC1", ": ", round(percentVar[1] * 100), "% Variance")
  yl <- paste0("PC2", ": ", round(percentVar[2] * 100), "% Variance")
  zl <- paste0("PC3", ": ", round(percentVar[3] * 100), "% Variance")
  axis_text <- c(xl, yl, zl) 

  group = factor(pcadf[[var]])
  g1 <- pcPlot(df = pcadf, vars = var, labels = labels, pc = c(1,2),...) + 
     labs(x = axis_text[1], y = axis_text[2])
  g2 <- pcPlot(df = pcadf, vars = var, labels = labels, pc = c(1,3),...) +
     labs(x = axis_text[1], y = axis_text[3])
  g3 <- pcPlot(df = pcadf, vars = var, labels = labels, pc = c(3,2),...) +
     labs(x = axis_text[3], y = axis_text[2])    
  if(!is.null(pc)){
    g <- switch(pc, p1 = g1, p2 = g2, p3 = g3)
    return(g)
  }
  
  else {
  leg<-getLegend(g1)
  ps = list(g1,g3,g2)
  if(allocation == 'flat'){
    grid.arrange(arrangeGrob(g1 + theme(legend.position="none"),
                           g2 + theme(legend.position="none"),
                           g3 + theme(legend.position="none"),
                           nrow=1,top = "Principal Components Analysis"),
               leg, nrow=2,heights=c(10, 1))
  }
  else if(allocation =='align'){
    
    ps.none <- lapply(ps, function(x) arrangeGrob(x + theme(legend.position="none")))
    ps.none[[length(ps)+1]] <-leg
    grid.arrange(grobs=ps.none, ncol=2, nrow=2)
  }
 }
}

#' plotSizefactor
#' Create size factors generated by vst, equivalent as running estimateSizeFactors
#' @param object an RNAqc instance
#' @param group color grouping variable
#' @param ... settings for geom_point
#' @return Sizefactor plot
#' @export

plotSizefactor <- function(object, group,...){
  out <- starPCA(object)[[1]]
  out$label <- factor(out$label, levels = out$label) ## Lock the order as is the same as dataframe
  ggplot(out, aes_string(x = "label", y = "sizeFactor",color = group))+
    geom_point(...) +
    labs(x = "Samples", y = "SizeFactors",color = group) +
    theme_classic() +
    theme(axis.text=element_text(size=10),
          axis.title=element_text(size=12, face="bold"),
          plot.title=element_text(face="italic"),
          axis.text.x=element_text(hjust=1))
}

#' Create normalized expression
#' generate dataset ready for scatter plot
#' @importFrom SummarizedExperiment assay
#' @param object An RNAqc instance
#' @param target a vector of gene of interest
#' @return dataframe for plotting
#' @export
#' 
normalCounts <- function(object, target){
  if(sum(is.na(normAssay(object))) != 0){vsd <- vst(object = object) 
                                      n_expression <- assay(vsd)
                                      }else n_expression <- normAssay(object)

  if(!"gene_name" %in% colnames(mcols(object))){
      warning("Annotation is not detected!")
      n_expression %>% t() %>% as.data.frame() %>% 
      dplyr::select(.,one_of(target)) %>%
      rownames_to_column(var = "uid")%>% 
      tidyr::gather(key = "ens_id_ver","value",-uid) -> expression
      plotdat <- expression %>% dplyr::full_join(colData(object) %>% as.data.frame() %>%                                                                
                                                 rownames_to_column(var = "uid"), by="uid") %>%
                                                 dplyr::rename(gene_name=ens_id_ver)
  }
  else{
      n_expression %>% t() %>% as.data.frame() %>% 
      rownames_to_column(var = "uid")%>% 
      tidyr::gather(key = "gene_id","value",-uid) -> expression
      plotdat <- expression %>% dplyr::full_join(colData(object) %>% as.data.frame() %>%
                              rownames_to_column(var = "uid"), by="uid") %>% 
                              dplyr::left_join(mcols(object)%>%
                              as.data.frame() %>% dplyr::select(gene_id,gene_name),by= "gene_id") %>%
                              dplyr::filter(gene_name %in% target)
  }                         
  return(plotdat)
  
  }



#' Check normalized expression
#' create scatter plot of normalized counts for a list of targeted genes
#' @importFrom stats as.formula
#' @param object An RNAqc instance
#' @param group grouping variable default to none
#' @param genelist a vector of gene of interest
#' @param gridvar variable for facet grid, default to NULL
#' @param boxplot value indicating whether show expression in box plot
#' @param ... settings for geom_point and theme
#' @return scatter plot of the expression
#' @export
#' 
checkExpression <- function(object, group, gridvar = NULL, target, boxplot= TRUE, ...){
  plotdata <- normalCounts(object, target) 
  g<-ggplot(plotdata, aes_string(x = "gene_name", y = "value", color = group)) +
    geom_point(..., position = position_jitterdodge())+
    labs(x = "Genes", y = "Expression Level")  +
    theme_classic() +
    theme(legend.position="bottom",
          axis.text=element_text(size=10),
          axis.title=element_text(size=12, hjust = 0.5, face="bold"),
          plot.title=element_text(face="italic"),
          axis.text.x=element_text(hjust=1,angle = 60),
          panel.border=element_rect(colour="black",fill=NA, size=0.2))

  
  if(boxplot) {g =  g + 
    geom_boxplot(outlier.shape = NA )
  }

  
  
  if(is.null(gridvar)) return (g)
  else return(g + facet_grid(as.formula(paste0(gridvar, "~", "."))))
}

#' Create Volcano plot for deseq2 results
#' @importFrom DESeq2 results
#' @param object An RNAqc after model-fitting through DESeq2
#' @param cutoff_nlog10p Cutoff for adjusted values
#' @param cutoff_log2fc Cutoff for log fold change
#' @param ... settings passed to results function from DESeq2
#' @return a volcano plot
#' @export
#' 

plotVolcano <- function(object, cutoff_nlog10p = -log10(0.05), 
                        cutoff_log2fc = log2(2), ...){
  
  res = results(object, ...) %>% data.frame %>%
     tibble::rownames_to_column('gene_id') %>% 
    left_join( mcols(dds) %>% data.frame, by= 'gene_id')
    
    dat_plt <- res %>%
      transmute(gene_name, 
                log2FoldChange,
                nlog10qval = -log10(padj),
                type = case_when(log2FoldChange > cutoff_log2fc & nlog10qval > cutoff_nlog10p ~ "Up-regulated",
                                 log2FoldChange < -cutoff_log2fc & nlog10qval > cutoff_nlog10p ~ "Down-regulated",
                                 TRUE ~ "Not significant")) %>%
      na.omit()
    
    dat_anno <- dat_plt %>% 
      filter(type != "Not significant")
    
    ggplot(dat_plt, aes(x = log2FoldChange, 
                        y = nlog10qval, 
                        color = type)) +
      geom_point() +
      geom_hline(yintercept = cutoff_nlog10p, 
                 lty = 2, color = 'gray') +
      geom_vline(xintercept = c(-cutoff_log2fc, cutoff_log2fc), 
                 lty = 2, color = 'gray') +
      labs(x = expression(log[2]~ "Fold Change"), 
           y = expression(-log[10]~ "q-value"), 
           title = "", color = "") +
      scale_color_manual(values = c("Up-regulated" = "#E62A38",
                                    "Down-regulated" = "#1E4684",
                                    "Not significant" = "grey"),
                         breaks = c("Up-regulated",
                                    "Down-regulated")) +
      theme_classic() +
      geom_text_repel(aes(x = log2FoldChange, 
                          y = nlog10qval, 
                          label = gene_name), 
                      data = dat_anno, 
                      color = "black", 
                      segment.color = "black", 
                      size = 3,
                      min.segment.length = 0) 
}
