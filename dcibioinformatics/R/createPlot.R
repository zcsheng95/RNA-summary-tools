#' get_legend
#' Helper function for getting legend
#' @param gplot ggplot type of plot
#' @return legend element of plot
#' @export
#'

get_legend<-function(gplot){
  tmp <- ggplot_gtable(ggplot_build(gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}




#' starPCA
#' Function for calculating PCA
#' @importFrom DESeq2 counts vst
#' @importFrom matrixStats rowVars
#' @importFrom stats prcomp
#' @param object an RNAqc object
#' @param ntop use top genes to calculate PCA
#' @return dataframe ready for pca plot
#'
starPCA <- function(object,ntop = 1000){
  if(!all(colnames(object) == colnames(counts(object)))){stop("Sample names not in same order!")}
  vsd <- vst(object = object)
  rv <- matrixStats::rowVars(assay(vsd))
  idx <- order(rv, decreasing = TRUE)[seq_len(min(ntop,length(rv)))]
  pca <- prcomp(t(assay(vsd)[idx, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  dat_pca <- as.data.frame(colData(vsd)) %>%
    rownames_to_column(var = "label") %>%
    mutate(pc1 = pca$x[, 1],
           pc2 = pca$x[, 2],
           pc3 = pca$x[, 3])
  return(list(dat_pca,percentVar))
}


#' PCplot
#' Create PCA plot 
#' @param df input dataframe
#' @param vars grouping variables
#' @param labels sample id
#' @param pc principal components to compare
#' @return ggplot type pca plot
#' 
#' 

PCplot <- function(df, vars, labels, pc){
  
  pc_1 = paste0("pc",pc)[1]
  pc_2 = paste0("pc",pc)[2]
  g <- ggplot(df, aes_string(x = pc_1, y = pc_2,
                            color=vars,
                            label = "label")) +
    geom_point(size = 4, alpha=1) +
    labs(color="") +
    # geom_text()+
    geom_vline(xintercept=0, linetype = "dashed") +
    geom_hline(yintercept=0, linetype = "dashed") +
    theme_classic() +
    theme(legend.position = "bottom")
   if(labels == TRUE){
     g <- g + geom_text_repel(segment.size = 0.2, segment.color = "grey50", direction =
                                "both",force = 5)
       
   }
  return(g)
}



#' createPCplot
#' This function takes the meta data and star counts 
#' use DESeq2 for estimating size factors before considering any experiment designs.
#' It requires the column names of the input count data matrix and the row names of the metadata have the same order
#' @import ggrepel
#' @importFrom gridExtra grid.arrange arrangeGrob
#' @param object an RNAqc object
#' @param var grouping variables
#' @param labels show the labels or not
#' @return PCA plot for pc1 vs pc2, pc1 vs pc3, pc2 vs pc3
#' @export


createPCplot <- function(object, var, labels = FALSE){
  out <- starPCA(object)
  pcadf <- out[[1]]
  percentVar <- out[[2]]
  xl <- paste0("PC1", ": ", round(percentVar[1] * 100), "% Variance")
  yl <- paste0("PC2", ": ", round(percentVar[2] * 100), "% Variance")
  zl <- paste0("PC3", ": ", round(percentVar[3] * 100), "% Variance")
  axis_text <- c(xl, yl, zl) 

  group = factor(pcadf[[var]])
  g1 <- PCplot(df = pcadf, vars = var, labels = labels, pc = c(1,2)) + 
     labs(x = axis_text[1], y = axis_text[2])
  g2 <- PCplot(df = pcadf, vars = var, labels = labels, pc = c(1,3)) +
     labs(x = axis_text[1], y = axis_text[3])
  g3 <- PCplot(df = pcadf, vars = var, labels = labels, pc = c(2,3)) +
     labs(x = axis_text[2], y = axis_text[3])    
  
  mylegend<-get_legend(g1)
  grid.arrange(arrangeGrob(g1 + theme(legend.position="none"),
                           g2 + theme(legend.position="none"),
                           g3 + theme(legend.position="none"),
                           nrow=1,top = "Principal Components Analysis"),
               mylegend, nrow=2,heights=c(10, 1))
  
}

#' SizeFactor
#' Create size factors generated by vst, equivalent as running estimateSizeFactors
#' @param object an RNAqc instance
#' @param group color grouping variable
#' @return Sizefactor plot
#' @export

plotSizefactor <- function(object, group){
  out <- starPCA(object)[[1]]
  ggplot(out, aes_string(x = "label", y = "sizeFactor",color = group))+
    geom_point(size = 4) +
    labs(x = "Samples", y = "SizeFactors",color = group) +
    theme_classic() +
    theme(axis.text=element_text(size=10),
          axis.title=element_text(size=12, face="bold"),
          plot.title=element_text(face="italic"),
          axis.text.x=element_text(hjust=1))
}

#' Create normalized expression
#' generate dataset ready for scatter plot
#' @importFrom SummarizedExperiment assay
#' @param object An RNAqc instance
#' @param genelist a vector of gene of interest
#' @return dataframe for plotting
#' 
normalCounts <- function(object, genelist){
  n_rnaqc <- vst(object)
  n_expression <- assay(n_rnaqc)
  n_expression %>% t() %>% as.data.frame() %>% rownames_to_column(var = "uid")%>% tidyr::gather(key = "ens_id_ver","value",-uid) -> expression

  if(!"symbol" %in% colnames(mcols(object))) stop("Must provide gene annotations!")
  plotdat <- expression %>% dplyr::full_join(colData(n_rnaqc) %>% as.data.frame() %>%
                              rownames_to_column(var = "uid"), by="uid") %>% 
                              dplyr::left_join(mcols(n_rnaqc)%>%
                              as.data.frame() %>% dplyr::select(ens_id_ver,symbol),by= "ens_id_ver")%>%
                              dplyr::filter(symbol %in% genelist)
  return(plotdat)
  
  }



#' Check normalized expression
#' create scatter plot of normalized counts for a list of targeted genes
#' @param object An RNAqc instance
#' @param group grouping variable default to none
#' @param genelist a vector of gene of interest
#' @param gridvar variable for facet grid, default to NULL
#' @return scatter plot of the expression
#' @export
#' 
checkExpression <- function(object, group, gridvar = NULL, genelist){
  plotdata <- normalCounts(object, genelist) 
  g<-ggplot(plotdata, aes_string(x = "symbol", y = "value", color = group)) +
    geom_point(size = 2.5,alpha = 0.5, position = position_dodge(width = 0.4)) +
    labs(x = "Genes", y = "Expression Level")  +
    theme_classic() +
    theme(legend.position="bottom",
          axis.text=element_text(size=10),
          axis.title=element_text(size=12, face="bold"),
          plot.title=element_text(face="italic"),
          axis.text.x=element_text(angle=0, hjust=1),
          panel.border=element_rect(colour="black",fill=NA, size=0.2))
  if(is.null(gridvar)) return (g)
  else return(g + facet_grid(as.formula(paste0(gridvar, "~", "."))))
}
