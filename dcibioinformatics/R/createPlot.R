#' getLegend
#' Helper function for getting legend
#' @param gplot ggplot type of plot
#' @return legend element of plot
#' @export
#'

getLegend<-function(gplot){
  tmp <- ggplot_gtable(ggplot_build(gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}




#' starPCA
#' Function for calculating PCA
#' @importFrom DESeq2 counts vst
#' @importFrom matrixStats rowVars
#' @importFrom stats prcomp
#' @param object an RNAqc object
#' @param ntop use top genes to calculate PCA
#' @return dataframe ready for pca plot
#'
starPCA <- function(object,ntop = 1000){
  if(!all(colnames(object) == colnames(counts(object)))){stop("Sample names not in same order!")}
  if(nrow(normAssay(object)) == 0){ncounts <- assay(vst(object = object))
  }else ncounts <- normAssay(object) 
  rv <- matrixStats::rowVars(ncounts)
  idx <- order(rv, decreasing = TRUE)[seq_len(min(ntop,length(rv)))]
  pca <- prcomp(t(ncounts[idx, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  dat_pca <- as.data.frame(colData(object)) %>%
    rownames_to_column(var = "label") %>%
    mutate(pc1 = pca$x[, 1],
           pc2 = pca$x[, 2],
           pc3 = pca$x[, 3])
  return(list(dat_pca,percentVar))
}


#' pcPlot
#' Create PCA plot 
#' @param df input dataframe
#' @param vars grouping variables
#' @param labels sample id
#' @param pc principal components to compare
#' @param ... size and alpha for geom_point
#' @return ggplot type pca plot
#' 
#' 

pcPlot <- function(df, vars, labels, pc,...){
  
  pc_1 = paste0("pc",pc)[1]
  pc_2 = paste0("pc",pc)[2]
  g <- ggplot(df, aes_string(x = pc_1, y = pc_2,
                            color=vars,
                            label = "label")) +
    geom_point(...) +
    labs(color="") +
    # geom_text()+
    geom_vline(xintercept=0, linetype = "dashed") +
    geom_hline(yintercept=0, linetype = "dashed") +
    theme_classic() +
    theme(legend.position = "bottom")
   if(labels == TRUE){
     g <- g + geom_text_repel(segment.size = 0.2, segment.color = "grey50", direction =
                                "both",force = 5)
       
   }
  return(g)
}



#' createPCplot
#' This function takes the meta data and star counts 
#' use DESeq2 for estimating size factors before considering any experiment designs.
#' It requires the column names of the input count data matrix and the row names of the metadata have the same order
#' @import ggrepel
#' @importFrom gridExtra grid.arrange arrangeGrob
#' @param object an RNAqc object
#' @param var grouping variables
#' @param labels show the labels or not
#' @param ... size and alpha for geom_point
#' @param pc select pcs to plot p1:p1 vs p2, p2:p1 vs p3, p3:p2 vs p3
#' @return PCA plot for pc1 vs pc2, pc1 vs pc3, pc2 vs pc3
#' @export


createPCplot <- function(object, var, labels = FALSE, pc = NULL,...){
  out <- starPCA(object)
  pcadf <- out[[1]]
  percentVar <- out[[2]]
  xl <- paste0("PC1", ": ", round(percentVar[1] * 100), "% Variance")
  yl <- paste0("PC2", ": ", round(percentVar[2] * 100), "% Variance")
  zl <- paste0("PC3", ": ", round(percentVar[3] * 100), "% Variance")
  axis_text <- c(xl, yl, zl) 

  group = factor(pcadf[[var]])
  g1 <- pcPlot(df = pcadf, vars = var, labels = labels, pc = c(1,2),...) + 
     labs(x = axis_text[1], y = axis_text[2])
  g2 <- pcPlot(df = pcadf, vars = var, labels = labels, pc = c(1,3),...) +
     labs(x = axis_text[1], y = axis_text[3])
  g3 <- pcPlot(df = pcadf, vars = var, labels = labels, pc = c(2,3),...) +
     labs(x = axis_text[2], y = axis_text[3])    
  if(!is.null(pc)){
    g <- switch(pc, p1 = g1, p2 = g2, p3 = g3)
    return(g)
  }
  
  else {
  mylegend<-getLegend(g1)
  grid.arrange(arrangeGrob(g1 + theme(legend.position="none"),
                           g2 + theme(legend.position="none"),
                           g3 + theme(legend.position="none"),
                           nrow=1,top = "Principal Components Analysis"),
               mylegend, nrow=2,heights=c(10, 1))
  }
  
}

#' plotSizefactor
#' Create size factors generated by vst, equivalent as running estimateSizeFactors
#' @param object an RNAqc instance
#' @param group color grouping variable
#' @param ... settings for geom_point
#' @return Sizefactor plot
#' @export

plotSizefactor <- function(object, group,...){
  out <- starPCA(object)[[1]]
  out$label <- factor(out$label, levels = out$label) ## Lock the order as is the same as dataframe
  ggplot(out, aes_string(x = "label", y = "sizeFactor",color = group))+
    geom_point(...) +
    labs(x = "Samples", y = "SizeFactors",color = group) +
    theme_classic() +
    theme(axis.text=element_text(size=10),
          axis.title=element_text(size=12, face="bold"),
          plot.title=element_text(face="italic"),
          axis.text.x=element_text(hjust=1))
}

#' Create normalized expression
#' generate dataset ready for scatter plot
#' @importFrom SummarizedExperiment assay
#' @param object An RNAqc instance
#' @param target a vector of gene of interest
#' @return dataframe for plotting
#' @export
#' 
normalCounts <- function(object, target){
  if(nrow(normAssay(rnaqc)) == 0){vsd <- vst(object = object) 
                                      n_expression <- assay(vsd)
                                      }else n_expression <- normAssay(object)

  if(!"gene_name" %in% colnames(mcols(object))){
      warning("Annotation is not detected!")
      n_expression %>% t() %>% as.data.frame() %>% 
      dplyr::select(.,one_of(target)) %>%
      rownames_to_column(var = "uid")%>% 
      tidyr::gather(key = "ens_id_ver","value",-uid) -> expression
      plotdat <- expression %>% dplyr::full_join(colData(object) %>% as.data.frame() %>%                                                                
                                                 rownames_to_column(var = "uid"), by="uid") %>%
                                                 dplyr::rename(gene_name=ens_id_ver)
  }
  else{
      n_expression %>% t() %>% as.data.frame() %>% 
      rownames_to_column(var = "uid")%>% 
      tidyr::gather(key = "gene_id","value",-uid) -> expression
      plotdat <- expression %>% dplyr::full_join(colData(object) %>% as.data.frame() %>%
                              rownames_to_column(var = "uid"), by="uid") %>% 
                              dplyr::left_join(mcols(object)%>%
                              as.data.frame() %>% dplyr::select(gene_id,gene_name),by= "gene_id") %>%
                              dplyr::filter(gene_name %in% target)
  }                         
  return(plotdat)
  
  }



#' Check normalized expression
#' create scatter plot of normalized counts for a list of targeted genes
#' @importFrom stats as.formula
#' @param object An RNAqc instance
#' @param group grouping variable default to none
#' @param genelist a vector of gene of interest
#' @param gridvar variable for facet grid, default to NULL
#' @param ... settings for geom_point
#' @return scatter plot of the expression
#' @export
#' 
checkExpression <- function(object, group, gridvar = NULL, target,...){
  plotdata <- normalCounts(object, target) 
  g<-ggplot(plotdata, aes_string(x = "gene_name", y = "value", color = group)) +
    geom_point(..., position = position_dodge(width = 0.4)) +
    labs(x = "Genes", y = "Expression Level")  +
    theme_classic() +
    theme(legend.position="bottom",
          axis.text=element_text(size=10),
          axis.title=element_text(size=12, face="bold"),
          plot.title=element_text(face="italic"),
          axis.text.x=element_text(angle=0, hjust=1),
          panel.border=element_rect(colour="black",fill=NA, size=0.2))
  if(is.null(gridvar)) return (g)
  else return(g + facet_grid(as.formula(paste0(gridvar, "~", "."))))
}
